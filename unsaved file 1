(defun length<= (length list) (or (zerop length) (and list (length<= (1- length) (cdr list))))
(defun -> (object &rest path) (cond ((null path) object) ((arrayp object) (let ((d (array-rank object))) (if (length<= d path) (apply (function ->) (apply (function aref) object (subseq path 0 d)) (nthcdr d path)) (make-array  (nthcdr (length path) (array-dimensions object)) :displaced-to object :displaced-index-offset (apply (function array-row-major-index) object (append path (make-list (- d (length path)) :initial-element 0))) :element-type (array-element-type object))))) ((and (listp object) (evenp (length object)) (loop for (k) on object by (function cddr) always (symbolp k)) (symbolp (first path))) (apply (function ->) (getf object (first path)) (rest path))) ((and (listp object) (every (function consp) object) (not (integerp (first path)))) (apply (function ->) (cdr (assoc (first path) object)) (rest path))) ((listp object) (apply (function ->) (elt object (first path)) (rest path))) ((hash-table-p object) (apply (function ->) (gethash (first path) object) (rest path))) ((typep object '(or structure-object standard-object)) (apply (function ->) (funcall (first path) object) (rest path))) ((or (functionp (first path)) (and (symbolp (first path)) (fboundp (first path)))) (apply (function ->) (funcall (first path) object) (rest path))) (t (error "This is not a compound object: â€”S" object))))

